# JVM

1、Java是否有内存泄露和内存溢出？
	
* 静态集合类，使用Set、Vector、HashMap等集合类的时候需要特别注意，当这些类被定义为静态的时候。他们的生存周期和应用程序一样长，可能发生内存泄漏。
* 监听器 在Java编程中，我们都需要定义很多的监听器，我们却没有删除这些监听器，增加了内存泄漏的可能。
* 物理连接 一些物理连接，比如数据库和网络，除非主动关闭。否则不会给回收。所以最好在try代码块重finally释放连接。
* 单例模式 因为单例模式对象初始化的时候将在整个JVM生命周期，如果它持有一个外部对象的引用，从而导致内存泄漏。

2、Java的内存模式是什么？（Java虚拟机内存的划分）为什么要实现内存模型？
	
* 内存模型就是为了现代计算机平台重保证程序可以正确的执行，当时不同的平台实现是不同的。
* 编译器中生成的指令顺序，可以与源代码的顺序不同。
* 编译器可能吧变量保存在寄存器而不是内存中。
* 处理器可以采用乱序或并行等方式来执行指令。
* 缓存可能会改变将写入变量提交到主内存的次序。
* 保存在处理器本地缓存中的值，对其他处理器是不可见的。

3、JVM垃圾处理的方法？（标记清除、复制、标记整理）
* 标记清除算法
	标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象。
	清除阶段：清除所有未被标记的对象。

	标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。

* 复制算法
	将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。

	现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

* 标记整理算法
	标记阶段：先通过根节点，标记所有从根节点开始的可达对象，为被标记的为垃圾对象
		整理阶段：将所有的存活对象压缩到内存的一段，之后清理边界所有的空间

	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。
		
	标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

4、GC的原理是什么？
* GC（Garbage Collection)，是垃圾收集器。

* 要准确理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析。

* 第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。

* 系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。

* 第二：“对什么东西”笼统的认为是Java对象并没有错。但是准确来讲，GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。

* 第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。

* 具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

5、新生代，老年代，持久带都存储什么？各有什么作用？
	
* 新生代： 
	大多数新生的对象在Eden区分配，当Eden区没有足够空间进行分配时，虚拟机就会进行一次MinorGC。
	在方法中new一个对象，方法调用完毕，对象就无用，这就是典型的新生代对象。（新生对象在Eden区经历过一次MinorGC并且被Survivor容纳的话，对象年龄为1，并且每熬过一次MinorGC，年龄就会加1，直到15，就会晋升到老年代）
	注意动态对象的判定：Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，大于或者等于该年龄的对象就可以直接进入老年代。

* 老年代： 
	在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中，而且大对象（占用大量连续内存空间的java对象如很长的字符串及数组）直接进入老年代。
		当survivor空间不够用时，需要依赖老年代进行分配担保。
	
* 永久代： 
	方法区
	主要存放Class和Meta的信息，Class在被加载的时候被放入永久代。 它和存放对象的堆区域不同，GC(Garbage Collection)不会在主程序运行期对永久代进行清理，所以如果你的应用程序会加载很多Class的话,就很可能出现PermGen space错误。

6、GC的应用可达性分析算法中，哪些对象可作为GC Roots的对象？

* 虚拟机栈中的引用对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用对象
* 本地方法栈中JNI引用对象

7、什么时候进行MinGC，什么时候进行FullGC？

* MinorGC：是指清理新生代
* MajorGC：是指清理老年代（很多MajorGC是由MinorGC触发的）
* FullGC：是指清理整个堆空间包括年轻代和永久代

* Minor GC触发条件：当Eden区满时，触发Minor GC。

* Full GC触发条件：

	* （1）调用System.gc时，系统建议执行Full GC，但是不必然执行

	* （2）老年代空间不足

	* （3）方法去空间不足

	* （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

	* （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

8、各个垃圾收集器是如何工作的？

	[内容较多](https://crowhawk.github.io/2017/08/15/jvm_3/)

9、用什么工具可以查出内存泄漏？
* 一. Memory Analyzer－是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件。

* 二. JProbe－分析Java的内存泄漏。

* 三. JProfiler－一个全功能的Java剖析工具，专用于分析J2SE和J2EE应用程序。它把CPU、执行绪和内存的剖析组合在一个强大的应用中，GUI可以找到效能瓶颈、抓出内存泄漏、并解决执行绪的问题。

* 四. JRockit－用来诊断Java内存泄漏并指出根本原因，专门针对Intel平台并得到优化，能在Intel硬件上获得最高的性能。

* 五. YourKit .NET & Java Profiling业界领先的Java和.NET程序性能分析工具。

* 六. AutomatedQA －AutomatedQA的获奖产品performance profiling和memory debugging工具集的下一代替换产品，支持Microsoft, Borland, Intel, Compaq 和 GNU编译器。可以为.NET和Windows程序生成全面细致的报告，从而帮助您轻松隔离并排除代码中含有的性能问题和内存/资源泄露问题。支持.Net 1.0,1.1,2.0,3.0和Windows 32/64位应用程序。

* 七. Compuware DevPartner Java Edition－包含Java内存检测,代码覆盖率测试,代码性能测试,线程死锁,分布式应用等几大功能模块


10、JVM如何加载一个类？

* 类加载过程：加载、验证、准备、解析、初始化

	* 加载
		在加载阶段，虚拟机主要完成三件事：
      		
      	1.通过一个类的全限定名来获取定义此类的二进制字节流。
      		2.将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构。
      		3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口

	* 验证
 		验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或其子类异常。验证过程分为四个阶段
    		
    	1.文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。
     	2.元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。
     	3.字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。
     	4.符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。

	* 准备
		准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值：

        pirvate static int size = 12;

        那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值。

	* 解析
		解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。
 
	* 初始化
		在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。

        至于使用和卸载阶段阶段，这里不再过多说明，使用过程就是根据程序定义的行为执行，卸载由GC完成。

11、JVM线程死锁如何判断？

[JConsole](http://www.cnblogs.com/ilahsa/archive/2013/06/03/3115410.html)

12、Java如何进行对象的实例化？例如Student s = new Student();

* 加载Student.class文件进内存
* 在栈内存为s开辟空间
* 在堆内存为学生对象开辟空间
* 对学生对象的成员变量进行默认初始化
* 对学生对象的成员变量进行显示初始化
* 通过构造方法对学生对象的成员变量赋值
* 学生对象初始化完毕，吧对象地址赋值给s变量

13、用什么工具调优JVM？

* 通过监控系统（如没有现成的系统，自己做一个简单的上报监控的系统也很容易）上对一些机器关键指标（gc time、gc count、各个分代的内存大小变化、机器的Load值与CPU使用率、JVM的线程数等）的监控报警，也可以看gc log和jstat等命令的输出，再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，基本上就能定位出当前的JVM是否有问题，以及是否需要调优。

* 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。
* 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。
* 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用jmap和MAT，基本就能定位到具体的代码。